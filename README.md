Лесникова Полина ИТ-6 Вариант 4


#Задание 1

##Задача 2

Сумма знаков.
Дана сигнатура метода: public int sumLastNums (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал результат
сложения двух последних знаков числах, предполагая, что знаков в числе не
менее двух. Подсказки:
int x=123%10; // х будет иметь значение 3
int у=123/10; // у будет иметь значение 12

Алгоритм:

Получаем последнюю цифру числа с помощью операции % 10
Получаем предпоследнюю цифру:
Сначала делим число на 10, чтобы убрать последнюю цифру
Затем берем остаток от деления на 10 от полученного результата
Складываем две полученные цифры
Возвращаем результат сложения

Тесты:

Введите число не менее 2 знаков, чтобы узнать сумму 2х последних членов: 
4568
Cумма двух последних знаков числа = 14

Введите число не менее 2 знаков, чтобы узнать сумму 2х последних членов: 
-67
Cумма двух последних знаков числа = 13

##Задача 4

Есть ли позитив.
Дана сигнатура метода: public bool isPositive (int x);
Необходимо реализовать метод таким образом, чтобы он принимал число x и
возвращал true, если оно положительное. 

Алгоритм:
Проверяем условие: сравниваем число x с нулем
Возвращаем результат:
x > 0 → возвращаем true
x <= 0 → возвращаем false

Тесты:

Введите число, чтобы узнать, положительное оно или нет: 
Положительное - true, Отрицательное - false 
-8
Число положительное = false

Введите число, чтобы узнать, положительное оно или нет: 
Положительное - true, Отрицательное - false 
3
Число положительное = true


##Задача 6

Большая буква.
Дана сигнатура метода: public bool isUpperCase (char x);
Необходимо реализовать метод таким образом, чтобы он принимал символ x и
возвращал true, если это большая буква в диапазоне от ‘A’ до ‘Z’. 

Алгоритм:

Проверяем диапазон символов: используем двойное условие
Сравниваем символ:
С ('A')
С ('Z')
Возвращаем результат:
Если символ находится в диапазоне от 'A' до 'Z' включительно → возвращаем true
В противном случае → возвращаем false

Тесты:

Введите символ a-z или A-Z, чтобы узнать, является ли он большой буквой: 
Большая буква - true, не большая буква - false
D
Символ является большой буквой = true

Введите символ a-z или A-Z, чтобы узнать, является ли он большой буквой: 
Большая буква - true, не большая буква - false
h
Символ является большой буквой = false

Введите символ a-z или A-Z, чтобы узнать, является ли он большой буквой: 
Большая буква - true, не большая буква - false
5
Надо ввести символ a-z или A-Z

##Задача 8

Делитель.
Дана сигнатура метода: public bool isDivisor (int a, int b);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
любое из принятых чисел делит другое нацело.

Алгоритм:

Проверяем два условия:
Первое условие: a делится на b без остатка (a % b == 0)
Второе условие: b делится на a без остатка (b % a == 0)
Используем логическое ИЛИ (||): если выполняется хотя бы одно из условий
Возвращаем результат: true если любое число делит другое нацело, иначе false

Тесты:

Введите 2 числа и узнайте делит ли одно из чисел другое нацело
true - делит, false - нет
Введите первое число: 
3
Введите второе число: 
6
Одно число делит другое нацело = true

Введите 2 числа и узнайте делит ли одно из чисел другое нацело
true - делит, false - нет
Введите первое число: 
2
Введите второе число: 
15
Одно число делит другое нацело = false

##Задача 10

Многократный вызов.
Дана сигнатура метода: public int lastNumSum(int a, int b)
Необходимо реализовать метод таким образом, чтобы он считал сумму цифр
двух чисел из разряда единиц. Выполните с его помощью последовательное
сложение пяти чисел и результат выведите на экран. Постарайтесь выполнить
задачу, используя минимально возможное количество вспомогательных
переменных.

Алгоритм:

Начальное вычисление: складываем последние цифры первых двух чисел
Последовательные вызовы: используем результат предыдущего вычисления как первый аргумент для следующего
Минимальное количество переменных: используем только одну переменную result

Тесты:

Введите 5 чисел для последовательного сложения разрядов единиц:
Введите число 1: 5
Промежуточный результат: 5
Введите число 2: 11
Промежуточный результат: 6
Введите число 3: 23
Промежуточный результат: 9
Введите число 4: 5
Промежуточный результат: 14
Введите число 5: 66
Промежуточный результат: 10
Итого: 10

#Задание 2

##Задача 2

Безопасное деление.
Дана сигнатура метода: public double safeDiv (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал деление x
на y, и при этом гарантировал, что не будет выкинута ошибка деления на 0. При
делении на 0 следует вернуть из метода число 0. Подсказка: смотри
ограничения на операции типов данных.

Алгоритм:

Проверяем делитель: если y равен 0
Обрабатываем особый случай: при делении на 0 возвращаем 0
Выполняем безопасное деление: если делитель не равен 0, выполняем деление с приведением типов
Возвращаем результат: результат деления как число с плавающей точкой

Тесты:

Введите первое число для безопасного деления без ошибки деления на 0 (x): 
5
Введите второе число (y): 
0
Результат деления: 0.0

Введите первое число для безопасного деления без ошибки деления на 0 (x): 
8
Введите второе число (y): 
2
Результат деления: 4.0

##Задача 4

Строка сравнения.
Дана сигнатура метода: public String makeDecision (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал строку,
которая включает два принятых методом числа и корректно выставленный
знак операции сравнения (больше, меньше, или равно).

Алгоритм:

Сравниваем два числа x и y
Определяем отношение между ними:
Если x > y → возвращаем строку с знаком "больше"
Если x < y → возвращаем строку с знаком "меньше"
Если x == y → возвращаем строку с знаком "равно"

Тесты:

Введите первое число для сравнения (x): 
5
Введите второе число для сравнения (y): 
7
Результат сравнения: 5<7

Введите первое число для сравнения (x): 
8
Введите второе число для сравнения (y): 
-1
Результат сравнения: 8>-1


##Задача 6

Тройная сумма.
Дана сигнатура метода: public bool sum3 (int x, int y, int z);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
два любых числа (из трех принятых) можно сложить так, чтобы получить
третье. 

Алгоритм:

Проверяем все возможные комбинации сложения двух чисел:
Первое и второе число дают третье: x + y == z
Первое и третье число дают второе: x + z == y
Второе и третье число дают первое: y + z == x
Используем логическое ИЛИ (||): если выполняется хотя бы одна из комбинаций
Возвращаем результат: true если любые два числа в сумме дают третье, иначе false

Тесты:

Можно ли получить число из суммы 2х других
 Да - true нет - false
Введите первое число (x): 
5
Введите второе число (y): 
7
Введите третье число (z): 
2
Результат: true


##Задача 8

Возраст.
Дана сигнатура метода: public String age (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой сначала будет число х, а затем одно из слов:
год
года
лет
Слово “год” добавляется, если число х заканчивается на 1, кроме числа 11.
Слово “года” добавляется, если число х заканчивается на 2, 3 или 4, кроме чисел
12, 13, 14.
Слово “лет”добавляется во всех остальных случаях.
Подсказка: оператор % позволяет получить остаток от деления

Алгоритм:

Определяем последнюю цифру числа: x % 10
Определяем последние две цифры числа: x % 100 (для исключений 11, 12, 13, 14)
Проверяем условия:
"год": если последняя цифра 1 И последние две цифры не 11
"года": если последняя цифра 2, 3 или 4 И последние две цифры не в диапазоне 12-14
"лет": во всех остальных случаях

Тесты:

Введите возраст (число), чтобы узнать что стоит после него: лет года год: 
5
Результат: 5 лет

##Задача 10

Вывод дней недели.
Дана сигнатура метода: public void printDays (String x);
В качестве параметра метод принимает строку, в которой записано название
дня недели. Необходимо реализовать метод таким образом, чтобы он выводил
на экран название переданного в него дня и всех последующих до конца недели
дней. Если в качестве строки передан не день, то выводится текст “это не день
недели”. Первый день понедельник, последний – воскресенье. Вместо if в данной
задаче используйте switch.

Алгоритм:

switch для определения переданного дня недели
отсутствие break позволяет выполнять последующие case'ы
Выводим дни последовательно: начиная с переданного дня до конца недели
Добавляем break только после воскресенья чтобы завершить выполнение
Обрабатываем неверный ввод в default случае

Тесты:

Введите день недели, чтоб получить его и все последующие: 
четверг
четверг
пятница
суббота
воскресенье

#Задание 3

##Задача 2

Числа наоборот.
Дана сигнатура метода: public String reverseListNums (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все числа от x до 0 (включительно).

Алгоритм:

Используем обратный цикл: начинаем с числа x и идем до 0 включительно
Добавляем числа в строку: на каждой итерации добавляем текущее число
Добавляем пробелы: между числами, но не после последнего числа
Возвращаем результирующую строку

Тесты:

Введите число (x), чтобы узнать все числа от х до 0: 
5
Результат: 5 4 3 2 1 0

##Задача 4

Степень числа.
Дана сигнатура метода: public int pow (int x, int y);
Необходимо реализовать метод таким образом, чтобы он возвращал результат
возведения x в степень y.
Подсказка: для получения степени необходимо умножить единицу на число x, и
сделать это y раз, т.е. два в третьей степени это 1*2*2*2

Алгоритм:

Инициализируем результат значением 1 (элемент для умножения)
Используем цикл, который повторяется y раз
На каждой итерации умножаем результат на x
Возвращаем итоговый результат

Тесты:

Введите основание - число которое нужно возвести в степень (x): 
2
Введите степень (y): 
5
Результат: 32

##Задача 6

Одинаковость.
Дана сигнатура метода: public bool equalNum (int x);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
все знаки числа одинаковы, и false в ином случае.
Подсказки:
intx=123%10; // х будет иметь значение 3
intу=123/10; // у будет иметь значение 12

Алгоритм:

Берем модуль
Проверяем однозначные числа: если число состоит из одной цифры, возвращаем true
Запоминаем последнюю цифру числа
Проходим по всем цифрам числа с помощью цикла:
На каждой итерации получаем текущую цифру (% 10)
Сравниваем ее с последней цифрой
Если цифры разные, сразу возвращаем false
Убираем обработанную цифру (/ 10)
Если все цифры одинаковы, возвращаем true

Тесты:

Введите число, чтобы узнать, все ли знаки числа одинаковы: 
 true - да false - нет 
12567
Результат: false

##Задача 8

Левый треугольник.
Дана сигнатура метода: public void leftTriangle (int x);
Необходимо реализовать метод таким образом, чтобы он выводил на экран
треугольник из символов ‘*’ у которого х символов в высоту, а количество
символов в ряду совпадает с номером строки.

Алгоритм:

Внешний цикл (i от 1 до x): отвечает за количество строк
Внутренний цикл (j от 1 до i): отвечает за количество звёздочек в каждой строке
Печать звёздочек: System.out.print("*") выводит звёздочки без перевода строки
Перевод строки: System.out.println() переходит на новую строку после каждой строки звёздочек

Тесты:

Введите высоту треугольника для его отображения: 
4
*
**
***
****

##Задача 10

Угадайка.
Дана сигнатура метода: public void guessGame()
Необходимо реализовать метод таким образом, чтобы он генерировал
случайное число от 0 до 9, далее считывал с консоли введенное пользователем
число и выводил, угадал ли пользователь то, что было загадано, или нет. Метод
запускается до тех пор, пока пользователь не угадает число. После этого
выведите на экран количество попыток, которое потребовалось пользователю,
чтобы угадать число.

Алгоритм:

Создается генератор случайных чисел Random
Генерируется случайное число от 0 до 9: secretNumber
Инициализируется счетчик попыток
while (true) - цикл выполняется до команды break
Внутри цикла на каждой итерации:
Создается новый Scanner для чтения ввода
Считывается число от пользователя
Увеличивается счетчик попыток: attempts++
Проверка условия:
Если userGuess == secretNumber:
Выводится "Вы угадали!"
Выполняется break - выход из цикла
Иначе:
Выводится сообщение "Вы не угадали..."
Цикл продолжается

Тесты:

Введите число от 0 до 9:
5
Вы не угадали, введите число от 0 до 9:
4
Вы не угадали, введите число от 0 до 9:
3
Вы не угадали, введите число от 0 до 9:
8
Вы не угадали, введите число от 0 до 9:
6
Вы не угадали, введите число от 0 до 9:
1
Вы не угадали, введите число от 0 до 9:
2
Вы не угадали, введите число от 0 до 9:
3
Вы не угадали, введите число от 0 до 9:
4
Вы не угадали, введите число от 0 до 9:
5
Вы не угадали, введите число от 0 до 9:
6
Вы не угадали, введите число от 0 до 9:
7
Вы не угадали, введите число от 0 до 9:
8
Вы не угадали, введите число от 0 до 9:
9
Вы угадали!
Вы отгадали число за 14 попытки

#Задание 4

##Задача 2

Поиск последнего значения.
Дана сигнатура метода: public int findLast (int[] arr, int x);
Необходимо реализовать метод таким образом, чтобы он возвращал индекс
последнего вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.

Алгоритм:

Начало метода - принимаем массив arr и искомое число x
Обратный цикл по массиву:
Начинаем с последнего элемента: i = arr.length - 1
Идем до первого элемента: i >= 0
Уменьшаем индекс на каждой итерации: i--
Проверка условия на каждой итерации:
Если arr[i] == x (текущий элемент равен искомому числу)
Немедленно возвращаем индекс i
Если цикл завершился без нахождения:
Возвращаем -1 (число не найдено в массиве)

Тесты:

Введите размер массива: 6
Введите элементы массива:
Элемент 1: 1
Элемент 2: 2
Элемент 3: 2
Элемент 4: 3
Элемент 5: 4
Элемент 6: 2
Введите число для поиска (x): 2
Индекс последнего вхождения: 5

##Задача 4

Добавление в массив.
Дана сигнатура метода: public int[]add (int[] arr, int x, int pos);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, который будет содержать все элементы массива arr, однако в позицию
pos будет вставлено значение x.

Алгоритм:

Создание нового массива:
Размер нового массива = размер исходного + 1
Копирование элементов до позиции вставки:
Цикл от 0 до pos-1
Копируем элементы без изменений: newArr[i] = arr[i]
Вставка нового элемента:
В позицию pos записываем значение x
newArr[pos] = x
Копирование элементов после позиции вставки:
Цикл от pos до конца исходного массива
Сдвигаем индексы на 1: newArr[i + 1] = arr[i]
Возврат результата:
Возвращаем новый массив newArr

Тесты:

Введите размер исходного массива: 5
Введите элементы массива:
Элемент 1: 1
Элемент 2: 2
Элемент 3: 3
Элемент 4: 4
Элемент 5: 5
Введите число для добавления (x): 9
Введите позицию для добавления (pos): 3
Результат: [1, 2, 3, 9, 4, 5]

##Задача 6

Реверс.
Дана сигнатура метода: public void reverse (int[] arr);
Необходимо реализовать метод таким образом, чтобы он изменял массив arr.
После проведенных изменений массив должен быть записан задом-наперед.

Алгоритм:

Цикл до середины массива
Достаточно пройти до середины, так как меняем элементы попарно
Обмен элементов на каждой итерации:
Сохраняем левый элемент во временную переменную: temp = arr[i]
Правый элемент перемещаем на место левого: arr[i] = arr[arr.length - 1 - i]
Временный элемент перемещаем на место правого: arr[arr.length - 1 - i] = temp

Тесты:

Введите размер массива: 5
Введите элементы массива:
Элемент 1: 1
Элемент 2: 2
Элемент 3: 3
Элемент 4: 4
Элемент 5: 5
Исходный массив: [1, 2, 3, 4, 5]
Перевернутый массив: [5, 4, 3, 2, 1]

##Задача 8

Объединение.
Дана сигнатура метода: public int[] concat (int[] arr1,int[] arr2);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором сначала идут элементы первого массива (arr1), а затем
второго (arr2).

Алгоритм:

Создание результирующего массива: Создаем новый массив result, длина которого равна сумме длин массивов arr1 и arr2
Копирование первого массива:
Проходим по всем элементам arr1
Копируем каждый элемент в начало результирующего массива
Копирование второго массива:
Проходим по всем элементам arr2
Копируем каждый элемент в результирующий массив, начиная с позиции после последнего элемента первого массива

Тесты:

Введите размер первого массива: 3
Введите элементы первого массива:
Элемент 1: 1
Элемент 2: 2
Элемент 3: 3
Введите размер второго массива: 3
Введите элементы второго массива:
Элемент 1: 4
Элемент 2: 5
Элемент 3: 6
Объединенный массив: [1, 2, 3, 4, 5, 6]

##Задача 10

Удалить негатив.
Дана сигнатура метода: public int[] deleteNegative (int[] arr);
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором записаны все элементы массива arr кроме отрицательных.

Алгоритм:

Подсчет неотрицательных элементов:
Проходим по всем элементам исходного массива
Считаем количество элементов, которые больше или равны 0
Создание результирующего массива:
Создаем новый массив длиной, равной количеству неотрицательных элементов
Заполнение результирующего массива:
Снова проходим по исходному массиву
Копируем только неотрицательные элементы в новый массив
Используем отдельный индекс для заполнения результирующего массива

Тесты:

Введите размер массива: 6
Введите элементы массива:
Элемент 1: 4
Элемент 2: -7
Элемент 3: -2
Элемент 4: 4
Элемент 5: 56
Элемент 6: 4
Исходный массив: [4, -7, -2, 4, 56, 4]
Массив без отрицательных элементов: [4, 4, 56, 4]
